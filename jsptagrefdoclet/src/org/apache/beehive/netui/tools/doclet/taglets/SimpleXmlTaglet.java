package org.apache.beehive.netui.tools.doclet.taglets;

import com.sun.javadoc.Tag;
import com.sun.tools.doclets.Taglet;
import org.apache.beehive.netui.tools.doclet.jsptagref.JspTagContext;
import org.apache.beehive.netui.tools.doclet.schema.JavadocTagType;
import org.apache.beehive.netui.tools.doclet.schema.JavadocTagsType;
import org.apache.beehive.netui.tools.doclet.schema.TextAndTagsType;
import org.apache.xmlbeans.XmlCursor;
import org.apache.xmlbeans.XmlObject;

import javax.xml.namespace.QName;

import java.net.URI;
import java.net.URISyntaxException;
import java.util.Map;
import java.util.StringTokenizer;

/**
 * A base implementation of the XmlTaglet interface. All other taglets provided
 * by this doclet extend this class. This taglet is also used as a default
 * implementation for many Javadoc tags -- see
 * {@link XmlTagletManager#initBuiltInTags(ConfigurationJspTagDoc)}
 * for more information. This class includes many utility methods that 
 * can be useful to its subclasses.
 * <p/>
 * The output XML generated by this taglet for a Javadoc tag such as
 * "@foo This is the text." will be as follows:
 * <pre>
 * &lt;javadoc-tag name="foo">
 *     &lt;content>This is the text&lt;/content>
 * &lt;/javadoc-tag>
 * </pre>
 */
public class SimpleXmlTaglet implements XmlTaglet
{
    protected static String REF_NAMESPACE =
            "http://apache.org/beehive/netui/tools/doclet/schema";
    protected String m_tagElementName = "";
    protected String m_tagName = "";
    protected String m_tagHead = "";
    private JspTagContext m_context;

    /**
     * Called by Javadoc to register this taglet, associating
     * the taglet with the tag it represents. This method will only be called
     * by the standard doclet (if the taglet is used with it).
     *
     * @param tagletMap A map that associates the tag with its handler.
     */
    public static void register(Map tagletMap)
    {
        SimpleXmlTaglet taglet = new SimpleXmlTaglet();
        Taglet t = (Taglet) tagletMap.get(taglet.getName());
        if (t != null)
        {
            tagletMap.remove(taglet.getName());
        }
        tagletMap.put(taglet.getName(), taglet);
    }

    /**
     * Sets the context instance corresponding to the JSP
     * tag for which the doclet is currently generating a topic.
     * This method is called by the {@link XmlTagletManager}
     * immediately before the manager calls the {@link #toXmlObject(Tag)}
     * method. To retrieve the context, taglets can call 
     * {@link #getContext()} from within their implementation of toXmlObject.
     * <p/>
     * Taglets can use the context object to retrieve information
     * about the current JSP tag as well as other tags, the
     * taglib, and aspects of the current Javadoc run.
     * 
     * @param context A context object corresponding to the current 
     * JSP tag.
     */
    public void setContext(JspTagContext context)
    {
        m_context = context;
    }

    /**
     * Gets the context object that was set by the {@link XmlTagletManager}.
     * Taglets can call this method to retrieve information about
     * the JSP tag for which documentation is currently being 
     * generated.
     * 
     * @return The context object.
     */
    public JspTagContext getContext()
    {
        return m_context;
    }

    /**
     * Receives the <em>jvdTag</em> Javadoc and returns an XML
     * representation of it.
     * 
     * @param jvdTag The Javadoc tag from which to generate XML.
     * @return An XML representation of <em>jvdTag</em> as an XMLBeans type.
     */
    public JavadocTagType toXmlObject(Tag jvdTag)
    {
        JavadocTagsType xmlJavadocTags = JavadocTagsType.Factory.newInstance();
        JavadocTagType xmlJavadocTag = xmlJavadocTags.addNewJavadocTag();
        xmlJavadocTag.setName(m_tagElementName);
        if (!m_tagHead.equals("")){ xmlJavadocTag.setHead(m_tagHead); }
        XmlCursor tagCursor = xmlJavadocTag.newCursor();
        tagCursor.toLastAttribute();
        tagCursor.toNextToken();
        XmlObject xmlContent = generateContentXml(jvdTag);
        XmlCursor contentCursor = xmlContent.newCursor();
        contentCursor.toNextToken();
        contentCursor.copyXml(tagCursor);
        tagCursor.dispose();
        contentCursor.dispose();
        return xmlJavadocTag;
    }

    /**
     * Receives an array of Javadoc tags and returns an XML
     * representation of them. XML for the tags in the array is merely concatenated.
     * 
     * @param jvdTagArray The Javadoc tag from which to generate XML.
     * @return An XML representation of <em>jvdTagArray</em> as an XmlObject instance.
     */
    public JavadocTagType toXmlObject(Tag[] jvdTagArray)
    {
        StringBuffer tagTextBuffer = new StringBuffer();
        JavadocTagType xmlTag = JavadocTagType.Factory.newInstance();
        for (int i = 0; i < jvdTagArray.length; i++)
        {
            xmlTag = toXmlObject(jvdTagArray[i]);
        }
        return xmlTag;
    }

    /**
     * Generates a &lt;content> element that simply includes the text of
     * the Javadoc tag represented by <em>jvdTag</em>, with any inline
     * Javadoc tags processed into XML.
     *
     * @param jvdTag The Javadoc tag.
     * @return The &lt;content> element as XML.
     */
    protected XmlObject generateContentXml(Tag jvdTag)
    {
        XmlObject xmlContent = XmlObject.Factory.newInstance();
        XmlCursor contentCursor = xmlContent.newCursor();
        contentCursor.toNextToken();

        // Create a container for the <description> element.
        contentCursor.beginElement(new QName(REF_NAMESPACE, "content"));
        contentCursor.toParent();
        XmlObject xmlDescription = contentCursor.getObject();

        // Put the contents into the container.
        xmlDescription.set(generateTextAndTagsXml(jvdTag.inlineTags()));
        contentCursor.dispose();
        return xmlContent;
    }

    /**
     * Removes the first "@" character from <em>string</em>.
     * Used to clean a Javadoc tag name.
     *
     * @param string The string to clean.
     * @return The string with the @ removed.
     */
    protected static String removeAtSign(String string)
    {
        if (string.charAt(0) == '@')
        {
            string = string.substring(1);
        }
        return string;
    }

    /**
     * Builds a sequence of "../" for the first part of a relative path up
     * to the root of the Javadoc output (the "doc root"). The sequence is built 
     * using the tag library's URI, such as "http://www.mydomain.com/foo/bartags",
     * where forward slashes are considered file path delimiters and the 
     * values in between are replace with "..".
     *
     * @param rawPath The URI from which to build a path up to the doc root.
     * @return A sequence of "../".
     */
    public String buildDocRoot(String rawPath)
    {
        URI uri = null;
        try
        {
            uri = new URI(rawPath);
        } catch (URISyntaxException urise)
        {
            getContext().getErrorReporter().printError("Error while generating the " +
                    "doc root from a taglib URI: \n" +
                    urise.getLocalizedMessage());
        }
        String tagLibPath = uri.getPath() + '/';
        // Sometimes the URI doesn't include a host.
        if (uri.getHost() != null)
        {
            tagLibPath = uri.getHost() + tagLibPath;
        }
        StringBuffer delimiters = new StringBuffer();
        StringBuffer cleanString = new StringBuffer();
        for (int i = 0; i < tagLibPath.length(); i++)
        {
            if (tagLibPath.charAt(i) != '/')
            {
                delimiters.append(tagLibPath.charAt(i));
            }
        }
        StringTokenizer tokens = new StringTokenizer(tagLibPath, delimiters.toString());
        while (tokens.hasMoreTokens())
        {
            cleanString.append(".." + tokens.nextToken());
        }
        String path = cleanString.toString();
        return path.substring(0, path.lastIndexOf("/"));
    }

    /**
     * Generates the content for XML corresponding to an inline tag. An
     * inline tag can be text or other inline tags such as @link -- 
     * which can, in turn, contain text or other inline tags. 
     * This method does approximately the same thing as the 
     * {@link #generateTextAndTagsXml(Tag[])} method,
     * except that it doesn't return a TextAndTagsType; instead,
     * it uses a cursor to directly insert the XML as it's being
     * generated. This is useful for elements that required mixed
     * content but which can't take the TextAndTagsType.
     *
     * @param jvdTag The Javadoc inline tag to add to the XML
     * content.
     * @param cursor The current position in the XML that was
     *               being generated when the tag was discovered.
     */
    protected static void generateInlineTagXml(Tag jvdTag,
                                                XmlCursor cursor,
                                                JspTagContext context)
    {
        if (jvdTag.kind().equals("Text"))
        {
            String text = jvdTag.text();
            cursor.insertChars(text);
        } else
        {
            JavadocTagType xmlJavadocTag = context.processJavadocTag(jvdTag, context);
            XmlObject xmlTagContainer = XmlObject.Factory.newInstance();
            XmlCursor containerCursor = xmlTagContainer.newCursor();
            containerCursor.toNextToken();
            containerCursor.beginElement(new QName(REF_NAMESPACE, "javadoc-tag"));
            containerCursor.toPrevToken();
            XmlCursor tagCursor = xmlJavadocTag.newCursor();
            tagCursor.moveXml(containerCursor);
            insertSiblingAfter(cursor, xmlTagContainer);
        }
    }

    /**
     * Inserts a sibling element <em>newSibling</em> after the element
     * at the position marked by <em>currentPosition</em>. This method
     * is used to build mixed content with a cursor.
     * 
     * @param currentPosition Position of the element after which the 
     * <em>newSibling</em> should be inserted.
     * @param newSibling The new sibling.
     */
    protected static void insertSiblingAfter(XmlCursor currentPosition, XmlObject newSibling)
    {
        if (newSibling != null)
        {
            currentPosition.toNextSibling();
            XmlCursor siblingCursor = newSibling.newCursor();
            siblingCursor.toNextToken();
            siblingCursor.copyXml(currentPosition);
        }
    }

    /**
     * Generates the content for XML corresponding to an array of Javadoc
     * inline tags -- such as the text of a method description that
     * includes text and other Javadoc tags. Both text and Javadoc tags
     * are considered by Javadoc to be "inline tags", so the array contains
     * both in the sequence in which they occurred in the description. 
     * <p/>
     * This method does approximately the same thing as the 
     * {@link #generateInlineTagXml(Tag, XmlCursor, JspTagContext)} method,
     * except that it returns a TextAndTagsType; the TextAndTagsType is
     * the type used for description &lt;lead> and &lt;detail> elements.
     * 
     * @param jvdInlineTags The inline Javadoc tags to render into XML.
     * @return An XML rendering of <em>jvdInlineTags</em>.
     */
    protected TextAndTagsType generateTextAndTagsXml(Tag[] jvdInlineTags)
    {
        TextAndTagsType xmlTagContent = TextAndTagsType.Factory.newInstance();
        XmlCursor cursor = xmlTagContent.newCursor();
        cursor.toNextToken();
        XmlCursor tagCursor = null;
        for (int i = 0; i < jvdInlineTags.length; i++)
        {
            Tag jvdTag = jvdInlineTags[i];
            if (jvdTag.kind().equals("Text"))
            {
                String text = jvdTag.text();
                cursor.insertChars(text);
            } else
            {
                JspTagContext context = getContext();
                JavadocTagType xmlJavadocTagContent = context.processJavadocTag(jvdTag, context);
                if (xmlJavadocTagContent != null)
                {
                    JavadocTagType xmlJavadocTag = xmlTagContent.addNewJavadocTag();
                    xmlJavadocTag.set(xmlJavadocTagContent);
                    tagCursor = xmlJavadocTag.newCursor();
                    tagCursor.moveXml(cursor);
                } else
                {
                    cursor.insertChars('{' + jvdTag.name() + ' ' + jvdTag.text() + '}');
                }
            }
        }
        if (tagCursor != null)
        {
            tagCursor.dispose();
        }
        return xmlTagContent;
    }
    
    /**
     * Gets the name (without the @ sign) of the Javadoc tag handled 
     * by this class.
     *
     * @return The tag's name.
     */
    public String getName()
    {
        return m_tagName;
    }

    /**
     * Sets the name of the Javadoc tag that this taglet instance will
     * handle. This method is called from the {@link XmlTagletManager} when
     * it is creating taglet instances to use during the Javadoc run.
     *
     * @param name The name of the Javadoc tag that this instance handles.
     */
    public void setName(String name)
    {
        m_tagName = name;
        m_tagElementName = name;
    }

    /**
     * Gets the tag head specified for the Javadoc tag. The tag head is the
     * value of the -tag option's third argument.
     * 
     * @return The tag head.
     */
    public String getTagHead()
    {
        return m_tagHead;
    }

    /**
     * Sets the tag head to use in XML output for the Javadoc tag that this
     * taglet instance handles. The tag head is text to use in the
     * HTML that results from transforming XML output. In the standard doclet,
     * the header text precedes the tag text in HTML output.
     * <p/>
     * This method is called from the {@link XmlTagletManager} when
     * it is creating taglet instances to use during the Javadoc run.
     *
     * @param tagHead The header for the output of the Javadoc tag that this
     *               instance handles.
     */
    public void setTagHead(String tagHead)
    {
        m_tagHead = tagHead;
    }

    /**
     * <code>true</code> if this tag may annotate a constructor;
     * otherwise, <code>false</code>.
     * <p/>
     * Part of the Taglet interface.
     */
    public boolean inConstructor()
    {
        return true;
    }

    /**
     * <code>true</code> if this tag may annotate a field;
     * otherwise, <code>false</code>.
     * <p/>
     * Part of the Taglet interface.
     */
    public boolean inField()
    {
        return true;
    }

    /**
     * <code>true</code> if this tag may annotate a method;
     * otherwise, <code>false</code>.
     * <p/>
     * Part of the Taglet interface.
     */
    public boolean inMethod()
    {
        return true;
    }

    /**
     * <code>true</code> if this tag may annotate an overview;
     * otherwise, <code>false</code>.
     * <p/>
     * Part of the Taglet interface.
     */
    public boolean inOverview()
    {
        return true;
    }

    /**
     * <code>true</code> if this tag may annotate a package summary;
     * otherwise, <code>false</code>.
     * <p/>
     * Part of the Taglet interface.
     */
    public boolean inPackage()
    {
        return true;
    }

    /**
     * <code>true</code> if this tag may annotate a class or
     * interface; otherwise, <code>false</code>.
     * <p/>
     * Part of the Taglet interface.
     */
    public boolean inType()
    {
        return true;
    }

    /**
     * <code>true</code> if this tag may occur inline with text;
     * otherwise, <code>false</code>.
     * <p/>
     * Part of the Taglet interface.
     */
    public boolean isInlineTag()
    {
        return true;
    }

    /**
     * Returns the string that the standard doclet should
     * use to represent this tag in HTML output. This
     * method is not used by XML doclets, but is implemented
     * here as a convenience for those extending this class
     * for taglets so that those taglets may also be used
     * with the standard doclet. This implementation
     * merely uses the tag's name as a header and the
     * tag's text as text. Override this method to change
     * the output for the standard doclet.
     *
     * @param jvdTag The Javadoc tag to process.
     * @return The HTML that should appear in output
     *         when this taglet is used with the standard
     *         doclet.
     */
    public String toString(Tag jvdTag)
    {
        return "<DT><B>" + m_tagHead + ":</B><DD>"
                + "<table><tr><td>"
                + jvdTag.text()
                + "</td></tr></table></DD>\n";
    }

    /**
     * Returns the string that the standard doclet should
     * use to represent this tag in HTML output. This
     * method is not used by XML doclets, but is implemented
     * here as a convenience for those extending this class
     * for taglets so that those taglets may also be used
     * with the standard doclet. This implementation
     * merely uses the tag's name as a header and the
     * tag's text as text. Override this method to change
     * the output for the standard doclet.
     *
     * @param jvdTagArray The Javadoc tags to process.
     * @return The HTML that should appear in output
     *         when this taglet is used with the standard
     *         doclet.
     */
    public String toString(Tag[] jvdTagArray)
    {
        if (jvdTagArray.length == 0)
        {
            return null;
        }
        String result = "\n<DT><B>" + m_tagHead + "</B><DD>";
        result += "<table><tr><td>";
        for (int i = 0; i < jvdTagArray.length; i++)
        {
            if (i > 0)
            {
                result += ", ";
            }
            result += jvdTagArray[i].text();
        }
        return result + "</td></tr></table></DD>\n";
    }

    /**
     * Returns the name of the Javadoc tag for which this taglet generates XML, along
     * with the unqualified name of the XML element that is generated.
     *
     * @return A string of the form "Tag name: tagName; Tag element: elementName"
     */
    public String toString()
    {
        return "Tag name: " + m_tagName + "; Tag element: " + m_tagElementName;
    }
}
